---
title: ""
format: 
  revealjs:
    theme: style_epa.scss
    chalkboard: TRUE
    progress: TRUE
    width: "1400"
---

```{r setup, include=FALSE}
library(countdown)
```

# R Shiny{background-image="img/title_left.PNG" background-size="cover"}

::: {style="margin-top: 20px; font-size: 1em; color: black;"}
Getting the Most out of Shiny at EPA
:::

::: {style="margin-top: 20px; font-size: 0.5em; color: black;"}
EPA R User Workshop (October 18, 2023)

Andrew Murray<br>Office of Research and Development<br>
Contamination Analysis and Innovative Solutions Branch.
:::


## Workshop Overview{background-image="img/title_left.PNG" background-size="cover"}
:::: {.columns}

::: {.column width="33%"}
**Building Shiny Apps (1:00 - 2:00)**

- What is Shiny?
- When and when **NOT** to use Shiny
- A Basic Application
- Understanding Reactivity
- Efficient Coding
:::

::: {.column width="33%"}
**Advanced Functionality (2:20 - 3:20)**

- Using Data from the Web
- Crosstalk
- Generating Reports
:::

::: {.column width="33%"}
**Advanced Functionality & Deployment (3:40 - 5:00)**

- Custom & EPA Styling
- POSIT Connect
- Deploying Your App
:::

::::

## What is Shiny?{background-image="img/title_left.PNG" background-size="cover"}

### TLDR:
Shiny allows you to deploy a web application that is capable of executing R code in real time.

### What does that mean?
This means that whoever is using a shiny app, can get information relevant to their needs and actually run analyses within the limits imposed by whoever wrote the application.

### Why should I use Shiny?
- Supercharge science communication (internally and externally)
- Increase collaboration
- Increased product value to the public
- Allows that code you worked so hard on to actually be used.

## When should I not use Shiny?{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="30%"}

### Flex Dashboards

- Flex dashboards filter but don't execute.
- Can be beneficial when:
  - you are focused on customized subsets of data
 - code does not need to be executed
 - you want to be able to email the dashboard to someone
 
 
[Read more about flexdashboard here](https://posit.co/blog/flexdashboard-easy-interactive-dashboards-for-r/)
 
:::

::: {.column width="70%"}
![[flexdashboard example](https://jjallaire.shinyapps.io/shiny-ggplot2-diamonds/)](img/flexdashboard.png){width=70%}
:::
::::

## Shiny Implementations{background-image="img/body_top.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="40%"}
Shiny is used for all sorts of applications:

- Mapping and Routing
- Data Visualization
- Automated Reports
- Surveys
- A lot more...

The best way to get inspired is to check out what others are doing:

[EPA POSIT Connect Server](https://rstudio-connect.dmap-stage.aws.epa.gov/connect/#/content/listing?filter=min_role:viewer&filter=content_type:all&view_type=compact)

[R Shiny Gallery](https://shiny.posit.co/r/gallery/)
:::

::: {.column width="60%"}
![An Example Shiny App](img/EJ_App.png){width=80%}
:::
::::

## A Basic Shiny App{background-image="img/body_top.PNG" background-size="cover"}

There are two basic components to every shiny app:

:::: {.columns}

::: {.column width="50%"}
- The User Interface

This is where we design the look and feel of the app

```{r, echo = TRUE, eval = FALSE}
# Define UI for application that shows a map
ui <- fluidPage(
  # Selector
  selectInput(
    inputId = "fCast",
    label = "Select a Forecast",
    choices = sf$fLabel,
    selected = sf$fLabel[1]),
  # Finished Map
  leafletOutput("map")
)
```
:::

::: {.column width="50%"}
- The Server

This is where the R code is executed

```{r, echo = TRUE, eval = FALSE}
# Define server logic required to render a map
server <- function(input, output) {

  # Filter the hurricane tracks
  sf.filt <- reactive(
    sf%>%
      filter(fLabel == input$fCast)
  )
  
  # Render the map
  output$map <- renderLeaflet(
    leaflet(sf.filt())%>%
      addTiles()%>%
      addPolygons())
}
```
:::
::::

## Components of the UI: Inputs{background-image="img/body_top.PNG" background-size="cover"}

:::: {.columns}

::: {.column width="40%"}
- The User Interface

This is where we design the look and feel of the app

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="3-8"}
# Define UI for application that shows a map
ui <- fluidPage(
  # Selector
  selectInput(
    inputId = "fCast",
    label = "Select a Forecast",
    choices = sf$fLabel,
    selected = sf$fLabel[1]),
  # Finished Map
  leafletOutput("map")
)
```
:::

::: {.column width="60%"}

We are using a 'select' input which allows the user to select a single option.

We have defined our input with the following variables:

- `inputId` -- gives us an id to use later on when we write code
- `label` -- adds some text above the input
- `choices` -- the list the user can select from
- `selected` -- a default selection


Check out the [Shiny cheatsheet](https://shiny.posit.co/r/articles/start/cheatsheet/) for more input examples.

:::
::::


## Components of the UI: Outputs{background-image="img/body_top.PNG" background-size="cover"}

:::: {.columns}

::: {.column width="40%"}
- The User Interface

This is where we design the look and feel of the app

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="9-10"}
# Define UI for application that shows a map
ui <- fluidPage(
  # Selector
  selectInput(
    inputId = "fCast",
    label = "Select a Forecast",
    choices = sf$fLabel,
    selected = sf$fLabel[1]),
  # Finished Map
  leafletOutput("map")
)
```
:::

::: {.column width="60%"}

Outputs have specific functions to make them viewable within the application. Here we are showing a leaflet app, so we use the `leafletOutput()` function. This partners with the render function: `renderLeaflet()` that lives in the server portion of our code.

Some common output types are:

- `dataTableOutput()`
- `plotOutput()`
- `imageOutput()`
- `textOutput()`

:::
::::

## The Server{background-image="img/body_top.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="50%"}
```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="4-8|10-14"}
# Define server logic required to render a map
server <- function(input, output) {

  # Filter the hurricane tracks
  sf.filt <- reactive(
    sf%>%
      filter(fLabel == input$fCast)
  )
  
  # Render the map
  output$map <- renderLeaflet(
    leaflet(sf.filt())%>%
      addTiles()%>%
      addPolygons())
}
```
:::

::: {.column width="50%"}
The server portion of our app is doing two things

1. Creating a reactive sf object that is a filtered subset of our data based on our select input

2. Rendering a leaflet map using the reactive sf object and assigning it to an input that can be called in the user interface (UI)


Notice anything familiar from the UI?

:::
::::

## UI &#x2192; Server{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="50%"}

UI

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="5"}
# Define UI for application that shows a map
ui <- fluidPage(
  # Selector
  selectInput(
    inputId = "fCast",
    label = "Select a Forecast",
    choices = sf$fLabel,
    selected = sf$fLabel[1]),
  # Finished Map
  leafletOutput("map")
)
```

<div style="text-align: right"> `input$fCast` feeds into the server {{< fa arrow-right >}} </div>


:::

::: {.column width="50%"}

Server

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="7"}
# Define server logic required to render a map
server <- function(input, output) {

  # Filter the hurricane tracks
  sf.filt <- reactive(
    sf%>%
      filter(fLabel == input$fCast)
  )
  
  # Render the map
  output$map <- renderLeaflet(
    leaflet(sf.filt())%>%
      addTiles()%>%
      addPolygons())
}
```
:::
::::

## UI &#x2190; Server{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="50%"}

UI

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="10"}
# Define UI for application that shows a map
ui <- fluidPage(
  # Selector
  selectInput(
    inputId = "fCast",
    label = "Select a Forecast",
    choices = sf$fLabel,
    selected = sf$fLabel[1]),
  # Finished Map
  leafletOutput("map")
)
```
<div style="text-align: right"> {{< fa arrow-up >}} `output$map` feeds into the server </div>

:::

::: {.column width="50%"}

Server

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="11"}
# Define server logic required to render a map
server <- function(input, output) {

  # Filter the hurricane tracks
  sf.filt <- reactive(
    sf%>%
      filter(fLabel == input$fCast)
  )
  
  # Render the map
  output$map <- renderLeaflet(
    leaflet(sf.filt())%>%
      addTiles()%>%
      addPolygons())
}
```
:::
::::

## Reactive Expressions vs. Observers{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="45%"}
Reactive Values are **lazy**

- Used to create something to be used somewhere else
  - Could be a text string, a data frame, an sf object etc...
  - Does not run until it has to
  - Typically used as a first step in whatever code you are running

:::

::: {.column width="10%"}
:::


::: {.column width="45%"}
Observers are **eager**

- The code inside an observer will run whenever **ANY** input inside of it is changed
- When the code runs, it will trigger any upstream reactive values
- Observers should be downstream of any large data to conserve computation time.
- Typically used to create outputs that are ready to be sent back to the UI for the end user to see.

:::
::::

## Reactive Expressions vs. Observers (Exercise){background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="80%"}

Navigate to the 'Apps' folder in the workshop repository and open the app called '02_reactive'

- This simple application loads the iris dataset and generates a plot
- Without changing any of the code run the app
  - Why is nothing showing up?
- Experiment with commenting out the reactive expression in the server part of the code and un-commenting the observer functions.
  - How does the functionality of the application change?
  
Try to re-write the code so that:

**A.** The iris data frame is filtered within an `eventReactive()` expression

**B.** A plot is displayed only when you click the 'Apply Filter' button. 

:::

::: {.column width="20%"}

![](https://media.giphy.com/media/LBsqN9KIwOrIx1CJ08/giphy.gif){width=100%}

```{r}
countdown(minutes = 5,
          warn_when = 30)
```
:::
::::

## Events{background-image="img/title_left.PNG" background-size="cover"}

There are two main variations of reactive and observe:

Reactivity:

- `reactive()`
- `eventReactive()`

Observer:

- `observe()`
- `observeEvent()`

observe and reactive will execute on their own. Adding the event, links it to a trigger. A trigger is typically a button but could be another reactive value.

## Efficient Coding{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}

::: {.column width="50%"}

### Do:

- Load as much data on the front end as you can
- filter as quickly and efficiently as possible

### Don't:

- Repeatedly load or download redundant data
- Perform redundant operations

:::

::: {.column width="50%"}

### Exercise

:::

::::

## Layouts


- [Layout Guide](https://shiny.posit.co/r/articles/build/layout-guide/)


### Your Turn!



