---
title: ""
format: 
  revealjs:
    theme: style_epa.scss
    chalkboard: TRUE
    width: "1400"
    slide-number: true
---

```{r setup, include=FALSE}
library(countdown)
```

# R Shiny{background-image="img/title_left.PNG" background-size="cover"}

::: {style="margin-top: 20px; font-size: 1em; color: black;"}
Getting the Most out of Shiny at EPA
:::

::: {style="margin-top: 20px; font-size: 0.5em; color: black;"}
EPA R User Workshop (October 18, 2023)

Andrew Murray<br>Office of Research and Development<br>
Contamination Analysis and Innovative Solutions Branch.
:::


## Workshop Overview{background-image="img/title_left.PNG" background-size="cover"}
:::: {.columns}

::: {.column width="33%"}
**Building Shiny Apps<br>(1:00 - 2:00)**

- What is Shiny?
- Flexdashboard
- A Basic Application
- Understanding Reactivity
- Efficient Coding
:::

::: {.column width="33%"}
**Advanced Functionality<br>(2:20 - 3:20)**

- Basic Layouts
- Using Data from the Web
- Crosstalk
- Generating Reports
:::

::: {.column width="33%"}
**Advanced Functionality & Deployment<br>(3:40 - 5:00)**

- Custom & EPA Styling
- POSIT Connect
- Deploying Your App
:::

::::

## What is Shiny?{background-image="img/title_left.PNG" background-size="cover"}

### TLDR:
Shiny allows you to deploy a web application that is capable of executing R code in real time.

### What does that mean?
This means that whoever is using a shiny app, can get information relevant to their needs and actually run analyses within the limits imposed by whoever wrote the application.

### Why should I use Shiny?
- Supercharge science communication (internally and externally)
- Increase collaboration
- Increased product value to the public
- Allows that code you worked so hard on to actually be used.

## When should I not use Shiny?{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="30%"}

### Flex Dashboards

- Flex dashboards filter but don't execute.
- Can be beneficial when:
  - you are focused on customized subsets of data
 - code does not need to be executed
 - you want to be able to email the dashboard to someone
 
 
[Read more about flexdashboard here](https://posit.co/blog/flexdashboard-easy-interactive-dashboards-for-r/)
 
:::

::: {.column width="70%"}
![[flexdashboard example](https://jjallaire.shinyapps.io/shiny-ggplot2-diamonds/)](img/flexdashboard.png){width=70%}
:::
::::

## Shiny Implementations{background-image="img/body_top.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="40%"}
Shiny is used for all sorts of applications:

- Mapping and Routing
- Data Visualization
- Automated Reports
- Surveys
- A lot more...

The best way to get inspired is to check out what others are doing:

[EPA POSIT Connect Server](https://rstudio-connect.dmap-stage.aws.epa.gov/connect/#/content/listing?filter=min_role:viewer&filter=content_type:all&view_type=compact)

[R Shiny Gallery](https://shiny.posit.co/r/gallery/)
:::

::: {.column width="60%"}
![An Example Shiny App](img/EJ_App.png){width=80%}
:::
::::

## A Basic Shiny App{background-image="img/body_top.PNG" background-size="cover"}

There are two basic components to every shiny app:

:::: {.columns}

::: {.column width="50%"}
- The User Interface

This is where we design the look and feel of the app

```{r, echo = TRUE, eval = FALSE}
# Define UI for application that shows a map
ui <- fluidPage(
  # Selector
  selectInput(
    inputId = "fCast",
    label = "Select a Forecast",
    choices = sf$fLabel,
    selected = sf$fLabel[1]),
  # Finished Map
  leafletOutput("map")
)
```
:::

::: {.column width="50%"}
- The Server

This is where the R code is executed

```{r, echo = TRUE, eval = FALSE}
# Define server logic required to render a map
server <- function(input, output) {

  # Filter the hurricane tracks
  sf.filt <- reactive(
    sf%>%
      filter(fLabel == input$fCast)
  )
  
  # Render the map
  output$map <- renderLeaflet(
    leaflet(sf.filt())%>%
      addTiles()%>%
      addPolygons())
}
```
:::
::::

## Components of the UI: Inputs{background-image="img/body_top.PNG" background-size="cover"}

:::: {.columns}

::: {.column width="40%"}
- The User Interface

This is where we design the look and feel of the app

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="3-8"}
# Define UI for application that shows a map
ui <- fluidPage(
  # Selector
  selectInput(
    inputId = "fCast",
    label = "Select a Forecast",
    choices = sf$fLabel,
    selected = sf$fLabel[1]),
  # Finished Map
  leafletOutput("map")
)
```
:::

::: {.column width="60%"}

We are using a 'select' input which allows the user to select a single option.

We have defined our input with the following variables:

- `inputId` -- gives us an id to use later on when we write code
- `label` -- adds some text above the input
- `choices` -- the list the user can select from
- `selected` -- a default selection


Check out the [Shiny cheatsheet](https://shiny.posit.co/r/articles/start/cheatsheet/) for more input examples.

:::
::::


## Components of the UI: Outputs{background-image="img/body_top.PNG" background-size="cover"}

:::: {.columns}

::: {.column width="40%"}
- The User Interface

This is where we design the look and feel of the app

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="9-10"}
# Define UI for application that shows a map
ui <- fluidPage(
  # Selector
  selectInput(
    inputId = "fCast",
    label = "Select a Forecast",
    choices = sf$fLabel,
    selected = sf$fLabel[1]),
  # Finished Map
  leafletOutput("map")
)
```
:::

::: {.column width="60%"}

Outputs have specific functions to make them viewable within the application. Here we are showing a leaflet app, so we use the `leafletOutput()` function. This partners with the render function: `renderLeaflet()` that lives in the server portion of our code.

Some common output types are:

- `dataTableOutput()`
- `plotOutput()`
- `imageOutput()`
- `textOutput()`

:::
::::

## The Server{background-image="img/body_top.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="50%"}
```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="4-8|10-14"}
# Define server logic required to render a map
server <- function(input, output) {

  # Filter the hurricane tracks
  sf.filt <- reactive(
    sf%>%
      filter(fLabel == input$fCast)
  )
  
  # Render the map
  output$map <- renderLeaflet(
    leaflet(sf.filt())%>%
      addTiles()%>%
      addPolygons())
}
```
:::

::: {.column width="50%"}
The server portion of our app is doing two things

1. Creating a reactive sf object that is a filtered subset of our data based on our select input

2. Rendering a leaflet map using the reactive sf object and assigning it to an input that can be called in the user interface (UI)


Notice anything familiar from the UI?

:::
::::

## UI &#x2192; Server{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="50%"}

UI

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="5"}
# Define UI for application that shows a map
ui <- fluidPage(
  # Selector
  selectInput(
    inputId = "fCast",
    label = "Select a Forecast",
    choices = sf$fLabel,
    selected = sf$fLabel[1]),
  # Finished Map
  leafletOutput("map")
)
```

<div style="text-align: right"> `input$fCast` feeds into the server {{< fa arrow-right >}} </div>


:::

::: {.column width="50%"}

Server

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="7"}
# Define server logic required to render a map
server <- function(input, output) {

  # Filter the hurricane tracks
  sf.filt <- reactive(
    sf%>%
      filter(fLabel == input$fCast)
  )
  
  # Render the map
  output$map <- renderLeaflet(
    leaflet(sf.filt())%>%
      addTiles()%>%
      addPolygons())
}
```
:::
::::

## UI &#x2190; Server{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="50%"}

UI

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="10"}
# Define UI for application that shows a map
ui <- fluidPage(
  # Selector
  selectInput(
    inputId = "fCast",
    label = "Select a Forecast",
    choices = sf$fLabel,
    selected = sf$fLabel[1]),
  # Finished Map
  leafletOutput("map")
)
```
<div style="text-align: right"> {{< fa arrow-up >}} `output$map` feeds into the server </div>

:::

::: {.column width="50%"}

Server

```{r, echo = TRUE, eval = FALSE, 'code-line-numbers'="11"}
# Define server logic required to render a map
server <- function(input, output) {

  # Filter the hurricane tracks
  sf.filt <- reactive(
    sf%>%
      filter(fLabel == input$fCast)
  )
  
  # Render the map
  output$map <- renderLeaflet(
    leaflet(sf.filt())%>%
      addTiles()%>%
      addPolygons())
}
```
:::
::::

## Reactive Expressions vs. Observers{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="45%"}
Reactive Values are **lazy**

- Used to create something to be used somewhere else
  - Could be a text string, a data frame, an sf object etc...
  - Does not run until it has to
  - Typically used as a first step in whatever code you are running

:::

::: {.column width="10%"}
:::


::: {.column width="45%"}
Observers are **eager**

- The code inside an observer will run whenever **ANY** input inside of it is changed
- When the code runs, it will trigger any upstream reactive values
- Observers should be downstream of any large data to conserve computation time.
- Typically used to create outputs that are ready to be sent back to the UI for the end user to see.

:::
::::

## Reactive Expressions vs. Observers (Exercise){background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="80%"}

Navigate to the 'Apps' folder in the workshop repository and open the app called '02_reactive'

- This simple application loads the iris dataset and generates a plot
- Without changing any of the code run the app
  - Why is nothing showing up?
- Experiment with commenting out the reactive expression in the server part of the code and un-commenting the observer functions.
  - How does the functionality of the application change?
  
Try to re-write the code so that:

**A.** The iris data frame is filtered within an `eventReactive()` expression

**B.** A plot is displayed only when you click the 'Apply Filter' button. 

:::

::: {.column width="20%"}

![](https://media.giphy.com/media/LBsqN9KIwOrIx1CJ08/giphy.gif){width=100%}

```{r}
countdown(minutes = 5,
          warn_when = 30)
```
:::
::::

## Events{background-image="img/title_left.PNG" background-size="cover"}

There are two main variations of reactive and observe:

Reactivity:

- `reactive()`
- `eventReactive()`

Observer:

- `observe()`
- `observeEvent()`

observe and reactive will execute on their own. Adding the event, links it to a trigger. A trigger is most often a button but could be another reactive value or any type of input that changes.

## Efficient Coding{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}

::: {.column width="50%"}

### Do:

- Load as much data on the front end as you can
- filter as quickly and efficiently as possible

### Don't:

- Repeatedly load or download redundant data
- Perform redundant operations

```{r}
countdown(minutes = 5,
          warn_when = 30,
          left = 50)
```

:::

::: {.column width="50%"}

### Exercise

Open the app.R file in the 'Apps/03_efficient_code/' folder.

This app loads county level polygons from the `tigris` package and generates two simple outputs.

- Run the application and review the code to understand how the app is calling the data.
- Notice that the `counties()` function is called every time the user changes the state in the dropdown menu.
- Try your hand at rewriting the code so that the data is downloaded only once and create an observer to update the output map and plot when the state selection is switched.

:::

::::

## Layouts{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="20%"}

Shiny provides a number of pre-made layouts that can be almost infinitely customized. If you have experience with writing HTML, you could even write an entirely custom layout.

<br><br>

[Layout Guide](https://shiny.posit.co/r/articles/build/layout-guide/)
:::
::: {.column width="40%"}
![Sidebar](img/sidebar.png){width=80% fig-align="left"}


![Navlist](img/navlist.png){width=80% fig-align="left"}
:::
::: {.column width="40%"}
![Tabset](img/tabset.png){width=80% fig-align="left"}

![Grid](img/grid.png){width=80% fig-align="left"}

:::
::::

## Layouts: Example{background-image="img/title_left.PNG" background-size="cover"}

:::: {.columns}
::: {.column width="50%"}

```{r layout, echo = TRUE, eval = FALSE, 'code-line-numbers'="3,4,14,15,18"}
# Define UI for application that draws a histogram
ui <- fluidPage(
  titlePanel("Adding a Sidebar Layout"),
  sidebarPanel(
  selectInput("state","Select a State",
              choices = unique(sf$State),
              selected = "Ohio"),
  selectInput("x","Choose X Variable",
              choices = colnames(sf)[4:12],
              selected = "Med_House_Val"),
  selectInput("y","Choose y variable",
              choices = colnames(sf)[4:12],
              selected = "Population")
  ),
  mainPanel(
    plotOutput("plot"),
    leafletOutput("map")
  )
)
```

:::

::: {.column width="50%"}

### Open the App.R file in 'Apps/04_sidebar'

- Look at the UI section of the code to understand how the layout is set up
- Try to manipulate the layout of the application so that the plot and the map are side by side.

*hint: you'll want to use a fluidRow inside of the main panel with 2 columns.

check out the [Layout Guide](https://shiny.posit.co/r/articles/build/layout-guide/)

https://shiny.posit.co/r/articles/build/layout-guide/
:::

```{r}
countdown(minutes = 10,
          warn_when = 30,
          left = 50)
```

::::


## Crosstalk


## Generating Reports


## Fetching Data from an API


## Fetching Data from a feature Service


## Deploying to POSIT Connect


## PINS

